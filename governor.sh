#!/bin/bash

# Script to test governor efficiency

#########################################################################################
########### INPUT DATA: #################################################################
#########################################################################################
CORES=4			#number of cores -> max UTILIZATION will depend on this number
TASKS=10		#tasks for each taskset
TASKSETS=4 		#tasksets for each utilization value
UTIL_VALS=10 	#number of utilization values uniformly taken between 1.0 and 2*CORES - 1.0

# global vars:
BASEDIR="./governor-results" #output directory
SILENT="y" #discard all the output from geng.sh and rt-app commands

# Parameter list:
# $1 governor : string; $2 cpu_id : int
set_governor(){
	cpu_id=$2
	
	echo -n -e "\tAttempting to set $1 governor on CPU$2... "
	
	if [ -e /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors ]; then
		for i in $(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors); do
			if [ $i = $1 ] ; then
				gov_target=$i
			fi
		done
	else
		echo "Error: cpufreq sysfs is not available!"
		exit
	fi

	if [ ! $gov_target ] ; then
		echo "Error: Can't find $1 governor!"
		exit
	fi
	
	if [ -e /sys/devices/system/cpu/cpu$2/cpufreq/scaling_governor ]; then
		echo $1 > /sys/devices/system/cpu/cpu$2/cpufreq/scaling_governor
	else
		echo "Error can't find CPU$2!"
		exit
	fi
		
	current_gov=$(cat /sys/devices/system/cpu/cpu$2/cpufreq/scaling_governor)
	
	if [[ $current_gov == $1 ]]; then
		echo "Done! Current governor on CPU$2 is $current_gov"
	else
		echo "Error: Current governor on CPU$2 is $current_gov, but should be $1"
		exit
	fi
}

generate_tasksets(){
	#compute min and max utilization values
	U_min="1.0"
	U_max="2*$CORES-1.0"

	mkdir $BASEDIR/tasksets
	
	echo "Generating $((UTIL_VALS*TASKSETS)) tasksets with taskgen.py!"
	
	UTIL_VALS=$((UTIL_VALS-1))
	
	# generate utilization using geng.sh (requires taskgen.py)
	for i in $(seq -w 0 $UTIL_VALS)
	do
		# calculate U = U_min + (U_max - U_min)*i/UTIL_VALS
		U=$(echo "scale=4; $U_min + ($U_max - $U_min)*$i/$UTIL_VALS" | bc -q)
		if [[ "$SILENT" == "y" ]]; then
			bash geng.sh $BASEDIR/tasksets/U$i $TASKS $TASKSETS $U >/dev/null 2>/dev/null
		else
			bash geng.sh $BASEDIR/tasksets/U$i $TASKS $TASKSETS $U
		fi
		rm -rf $BASEDIR/tasksets/U$i # I dunno why the script also creates a folder...
		for i in $(seq -w 1 $TASKSETS); do echo -n "."; done
	done
	echo "DONE!"
}

# startup checks and clean of previous work
startup(){
	if [ "$(id -u)" != "0" ]; then
		echo "This script must be run as root"
		exit
	fi
	
	rm -rf $BASEDIR
	mkdir $BASEDIR

	if [[ ! -f "./geng.sh" || ! -f "./taskgen.py" ]]
	then
		echo "Error: geng.sh and taskgen.py are required to run this script. Place them in the same directory of this script!"
		exit
	fi

	if [[ ! -f "./governor.json" ]]
	then
		echo "Error: governor.json must be in the same directory of this script!"
		exit
	fi
	if [ -z "$(command -v rt-app)" ]
	then
		echo "Error: rt-app is not installed. Please add it to PATH!"
		exit
	fi

	if [[ ! -f "./freq_logger" ]]
	then
		if [[ ! -f "./freq_logger.c" ]]
		then
			echo "Error: freq_logger.c or freq_logger executable aren't available."
			exit
		else
			echo "Compiling freq_logger (assuming gcc is installed)"
			gcc ./freq_logger.c -o ./freq_logger
			if [[ ! -f "./freq_logger" ]]
			then
				echo "Error: Compilation failed (is gcc installed?)"
				exit
			else
				echo "freq_logger compiled!"
			fi
		fi
	fi
}

# generate a JSON from the taskgen.py output
# expect the first parameter to be the taskset file generated by geng.sh
convert_to_json(){
	taskset=$1
	filename="${taskset##*/}"
	name="${filename%.txt}"
	json="$WORKDIR/jsons/$name.json"

	echo -e "{" >> $json
	echo -e "\t\"tasks\" : {" >> $json

	### creating JSON taskset data
	i=0
	while read task_data ; do
		runtime="${task_data% *}"
		period="${task_data#* }"
		echo -e "\t\t\"thread-$i\" : {" >> $json
		echo -e "\t\t\t\"loop\" : -1," >> $json
		echo -e "\t\t\t\"runtime\" : $runtime," >> $json
		echo -e "\t\t\t\"timer\" : { \"ref\" : \"unique-$i\", \"period\" : $period }," >> $json
		echo -e "\t\t\t\"dl-runtime\" : $runtime," >> $json
		echo -e "\t\t\t\"dl-period\" : $period" >> $json
		i=$((i+1))
		if [[ $i -eq $TASKS ]]
		then
			echo -e "\t\t}" >> $json
		else
			echo -e "\t\t}," >> $json
		fi
	done < $taskset

	echo -e "\t}," >> $json
	cat "./governor.json" >> $json #copy the rest of the JSON
	
	### adjust json data
	sed -i 's="logdir" : .*,="logdir" : "'$WORKDIR'/logs/",=' $json
	sed -i 's/"log_basename" : .*,/"log_basename" : "'$name'",/' $json	
}

generate_tasksets_json(){
	## convert each taskset in $WORKDIR/tasksets in a .json
	mkdir $WORKDIR/jsons
	
	echo "$1 governor: Generating $(ls $BASEDIR/tasksets/*.txt | wc -l) rt-app JSON:"
	for taskset in $BASEDIR/tasksets/*.txt
	do
		convert_to_json "$taskset"
		echo -n "."
	done
	echo "DONE!"
}

# runs all tasksets with rt-app
run_rtapp(){
	mkdir $WORKDIR/logs

	echo "$1 governor: Running $(ls $WORKDIR/jsons/*.json | wc -l) rt-app tests:"

	./freq_logger "$BASEDIR/$1_freq.csv" &

	for json in $WORKDIR/jsons/*.json
	do
		echo -n "."
		if [[ "$SILENT" == "y" ]]; then
			rt-app $json >/dev/null 2>/dev/null
		else
			rt-app $json
		fi
	done
	echo "DONE!"

	killall freq_logger
}

# count occurrences of negative slacks
# 1st parameter is governor
log_postprocessing(){
	governor=$1
	negative_slacks=0
	total_samples=0

	echo ""
	echo "$governor governor: Extracting data from $(ls $WORKDIR/logs/*.log | wc -l) rt-app thread log files"

	for log in $WORKDIR/logs/*.log
	do
		echo -n "."
		while read line ; do
			if [[ $line == \#* ]] ; then
				continue
			fi
			slack="$(awk '{print $8}' <<< $line)"
			total_samples=$((total_samples+1))
			if (( slack < 0 )) ; then
				negative_slacks=$((negative_slacks+1))
			fi
		done < $log
	done
	echo "DONE!"
	miss_ratio_percentage=$(echo "scale=4; $negative_slacks/$total_samples*100" | bc -q)
	echo "Governor $governor: Negative slacks/total slacks: $negative_slacks/$total_samples"
	echo "Governor $governor: Miss ratio: $miss_ratio_percentage %"
	
	echo "Governor $governor: Negative slacks/total slacks: $negative_slacks/$total_samples" >> $BASEDIR/$governor-results.txt
	echo "Governor $governor: Miss ratio: $miss_ratio_percentage %" >> $BASEDIR/$governor-results.txt
}

# Run the test on the desired governor
# 1st parameter is governor name
test_governor(){
	governor=$1
	
	echo ""
	echo "Now testing \"$governor\" governor"
	
	if [ ! -d $BASEDIR/tasksets ]; then
		echo "Error: before testing a governor you must generate the tasksets!"
		exit
	fi
	
	WORKDIR=$BASEDIR/$governor
	mkdir $WORKDIR
	
	generate_tasksets_json "$governor"

	echo "Setting current governor to $governor:"
	for i in $(seq 0 $((CORES-1))); do
		set_governor "$1" "$i"
	done

	run_rtapp "$governor"
	log_postprocessing "$governor"
}

##################################################################################################
############ SCRIPT ENTRY POINT ##################################################################
##################################################################################################

# 1) checks
startup

# 2) generate once for all the tasksets (uses numpy from Python, may need 1GB swap file to install on devices with 512 MB of RAM)
generate_tasksets

# 3) start testing governors:
echo "Starting to test all available governors: $(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors | tr '\n' ' ')"
for i in $(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors); do
	test_governor $i
done




